===============================
Causal Consistency and Sessions
===============================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

In this guide, you can learn about **causal consistency** and **sessions**
in MongoDB.

Causal Consistency
------------------

If one operation influences a subsequent read or write
operation, these two operations have a causal relationship.
For example, updating item quantity *after* checking to ensure enough
stock to fulfill a purchase order is a causal relationship.

**Causal consistency** is the notion that all causally-related operations
should appear in the same order on all processes - that means every
member of a replica set or sharded cluster in MongoDB. Single node
databases - where only one node (or server) is running - are naturally causally
consistent.

To maintain causal consistency, the following guarantees must be satisfied:

.. list-table::
   :header-rows: 0
   :stub-columns: 1

   * - **Read your writes**
     - Read operations reflect the results of write operations that precede them.
   * - **Monotonic reads**
     - Read operations do not return results that correspond to an earlier
       state of the data than a preceding read operation.
   * - **Monotonic writes**
     - Write operations that must precede other writes are executed before those
       other writes.
   * - **Writes follow reads**
     - Write operations that must occur after read operations are executed after
       those read operations.

Illustrated Example, No Causal Consistency
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider the following example where **no** causal ordering is enforced.

The distributed system depicted below is a replica set with a primary (or leader)
that accepts all incoming client *writes* and two secondaries (or followers) that
replicate those writes. Any member of the replica set may service client *reads*.

.. figure:: /figures/replica_set_no_causal.png
   :alt: An image showing a replica set with no causal consistency guarantees.

   1. The client application writes order **234** to the primary.
   2. The primary responds that it has successfully applied the write.
   3. Order **234** is replicated to one of the secondaries.
   4. The client application reads the orders collection on a secondary.
   5. The targeted secondary hasn't seen order **234**, so it responds with no results.
   6. Order **234** is replicated from the primary to the other secondary.

The client makes an order through the application. The application writes the
order to the primary and reads from a secondary. If the read operation targets
a secondary that has yet to receive the replicated write, the application
fails to read its own write.


Implementation
``````````````

To ensure causal consistency, MongoDB uses a global logical clock based
on a `Lamport Clock <https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html>`__.
Every operation that changes data in the system is assigned a time when it
is applied to the primary. Every participant in the system - drivers, cluster members,
and query routers in sharded clusters - track and send their value of the
latest time in every message. This allows all participants to converge on the
latest time, regardless of if they are in another city, another country, or
orbiting another planet.

.. tip:: Adjust Latency Tolerances

   When deploying a solar system-wide cluster, MongoDB recommends timeouts
   are adjusted to accommodate the latency of the network. For example,
   ping times from Earth to Mars can range from ~3.5 minutes to ~15 minutes.


Illustrated Example, Causal Consistency
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following diagram depicts a replica set with causal consistency enforced.

.. figure:: /figures/replica_set_with_causal.png
    :alt: An image showing a replica set with causal consistency guarantees.

    1. The client application writes order **234** to the primary.
    2. The primary responds that it has successfully applied the write at time T1.
    3. Order **234** is replicated to one of the secondaries.
    4. The client application reads the orders collection after T1 on a secondary.
    5. The targeted secondary hasn't seen time T1, so must wait to respond.
    6. Order **234** is replicated from the primary to the other secondary.
    7. The secondary is able to respond with the contents of order **234**.

The client makes an order through the application. The application writes the
order to the primary, incrementing the clock. The client reads from a secondary,
also sending its' updated clock. The targeted secondary hasn't seen the write yet
**and** its clock is behind the primary's clock, so it must wait to respond. The write
is replicated to the secondary and the clock times sync, so the secondary is able
to respond to the read.

To learn more about causal consistency, see the following resources:
- :manual:`The MongoDB Manual entry </core/causal-consistency-read-write-concerns/>`
- `The MongoDB Engineering blog article <https://engineering.mongodb.com/post/ryp0ohr2w9pvv0fks88kq6qkz9k9p3>`__

Sessions
--------
